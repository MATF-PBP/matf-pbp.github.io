#include <stdio.h>
#include <stdlib.h>

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
sqlint32 id_predmeta;
char oznaka[21], 
     naziv[151];
short espb;
EXEC SQL END DECLARE SECTION;

// Niz identifikatora predmeta obradjenih od strane ovog programa.
// Ovde koristimo staticki niz radi ilustracije, ali broj predmeta nije poznat unapred, naravno,
// pa bi korektnije resenje koristilo dinamicki inicijalizovan niz.
sqlint32 obradjeni_predmeti[1000];
size_t broj_obradjenih_predmeta = 0u;

// Pomocne funkcije sa rad sa nizom identifikatora predmeta
int predmet_je_obradjen(sqlint32 id);
void oznaci_kao_obradjen(sqlint32 id);

// Pomocne funkcije za obradu gresaka i cekanja na katance
void is_error(const char *str);
int wait_for_lock();

int main() {
    EXEC SQL CONNECT TO stud2020 USER student USING abcdef;
    is_error("Connect");
    
    EXEC SQL SET CURRENT LOCK TIMEOUT 5;
    is_error("Set current lock timeout 5");
    
    EXEC SQL 
        DECLARE predmeti CURSOR WITH HOLD FOR 
        SELECT  ID, 
                TRIM(OZNAKA), 
                TRIM(NAZIV), 
                ESPB
        FROM    DA.PREDMET
        FOR     UPDATE OF ESPB;
    is_error("Declare predmeti");
    
    EXEC SQL OPEN predmeti;
    is_error("Open predmeti");
    
    printf("PREDMETI\n");

    for(;;) {
        EXEC SQL 
            FETCH   predmeti 
            INTO    :id_predmeta, 
                    :oznaka, 
                    :naziv, 
                    :espb;
        if (wait_for_lock()) {
            continue;
        }
        is_error("Fetch predmeti");

        if (SQLCODE == 100) {
            printf("Nema vise predmeta za obradjivanje!\n");
            break;
        }

        // Provera da li je predmet vec obradjen 
        // od strane ove instance aplikacije
        if (predmet_je_obradjen(id_predmeta)) {
            continue;
        }
        
        printf("\n---------------------------------------------------------------\n");
        printf("%5.5d %-10.10s %-40.40s %5.5d", id_predmeta, oznaka, naziv, espb);
        printf("\n---------------------------------------------------------------\n");

        printf("\nDa li zelite da uvecate broj ESPB za ovaj predmet za 1? [d/n] ");
        char odgovor_od_korisnika = getchar();
        getchar();  // novi red

        if (odgovor_od_korisnika == 'd') {
            // Azuriranje podataka zahteva katanac za menjanje podataka
            EXEC SQL 
                UPDATE  DA.PREDMET
                SET     ESPB = ESPB + 1
                WHERE   CURRENT OF predmeti;
            if (wait_for_lock()) {
                continue;
            }
            is_error("Update");

            // Slicno kao i FETCH, naredba SELECT INTO zahteva katanac za citanje
            EXEC SQL 
                SELECT  ESPB
                INTO    :espb
                FROM    DA.PREDMET
                WHERE   ID = :id_predmeta;
            if (wait_for_lock()) {
                continue;
            }
            is_error("Select into");

            printf("Broj ESPB je sada %hd\n", espb);
        }

        // Evidentiramo izmene u nizu namenjenim za to.
        oznaci_kao_obradjen(id_predmeta);
        
        // Potvrdjivanje izmena u tekucoj transakciji
        EXEC SQL COMMIT;
        is_error("Commit");
    }

    EXEC SQL CLOSE predmeti;
    is_error("Close predmeti");

    // Vracamo istek vremena na podrazumevanu vrednost
    EXEC SQL SET CURRENT LOCK TIMEOUT NULL;
    is_error("Set current lock timeout null");

    EXEC SQL COMMIT;
    is_error("Potvrdjivanje izmena");

    EXEC SQL CONNECT RESET;
    is_error("Connect reset");

    return 0;
}

void is_error(const char *str) {
    if(SQLCODE < 0) {
        fprintf(stderr, "Greska %d: %s\n", SQLCODE, str);

        EXEC SQL ROLLBACK;

        EXEC SQL CONNECT RESET;
        exit(EXIT_FAILURE);
    }
}

int wait_for_lock() {
    if (SQLCODE == -911 || SQLCODE == -913) {
        printf("Objekat je zakljucan od strane druge transakcije. "
            "Sacekati neko vreme...\n");

        EXEC SQL ROLLBACK;
        is_error("Rollback");

        EXEC SQL OPEN predmeti;    
        is_error("Open predmeti - obrada cekanja");

        return 1;
    }
    return 0;
}

int predmet_je_obradjen(sqlint32 id) {
    for (unsigned i = 0; i < broj_obradjenih_predmeta; ++i) {
        if (obradjeni_predmeti[i] == id) {
            return 1;
        }
    }
    return 0;
}

void oznaci_kao_obradjen(sqlint32 id) {
    obradjeni_predmeti[broj_obradjenih_predmeta++] = id;
}